use crate::parsing::builtins::Builtin::*;
use bincode::{Decode, Encode};

#[derive(Debug, Clone, Decode, Encode)]
pub enum Builtin {
    Val,
    Fn,
    Mul,
    Div,
    Sub,
    Add,
    Mod,
    Branch,
    Lt,
    Gt,
    Eq,
    Neq,
    LtEq,
    GtEq,
    Or,
    And,
    Not,
    BitOr,
    BitAnd,
    BitXor,
    BitInv,
    BitShiftLeft,
    BitShiftRight,
    CastInt,
    CastFloat,
    StringFrom,
    SomeOf,
    NoneOf,
    BranchOnSome,
    Nop,
    Import,
    PeekStack,
    Loop,
    Break,
    Continue,
    Exit,
}

pub fn evaluate_builtin(name: &String) -> Option<Builtin>
{
    match name.as_str() {
        "*" => Some(Mul),
        "+" => Some(Add),
        "-" => Some(Sub),
        "%" => Some(Mod),
        "<" => Some(Lt),
        ">" => Some(Gt),
        "==" => Some(Eq),
        "<>" => Some(Neq),
        "<=" => Some(LtEq),
        ">=" => Some(GtEq),
        "not" => Some(Not),
        "&" => Some(BitAnd),
        "@" => Some(PeekStack),
        "|" => Some(BitOr),
        "and" => Some(And),
        "or" => Some(Or),
        "/" => Some(Div),
        "^" => Some(BitXor),
        "<<" => Some(BitShiftLeft),
        ">>" => Some(BitShiftRight),
        "int" => Some(CastInt),
        "float" => Some(CastFloat),
        "string" => Some(StringFrom),
        "some_of" => Some(SomeOf),
        "none" => Some(NoneOf),
        "branch" => Some(Branch),
        "guard" => Some(BranchOnSome),
        "_" => Some(Nop),
        "~" => Some(BitInv),
        "fn" => Some(Fn),
        "val" => Some(Val),
        "use" => Some(Import),
        "loop" => Some(Loop),
        "break" => Some(Break),
        "continue" => Some(Continue),
        "exit" => Some(Exit),
        _ => None
    }
}